diff -rupN qt-orig/src/gui/dialogs/qcolordialog_mac.mm qt-patched/src/gui/dialogs/qcolordialog_mac.mm
--- qt-orig/src/gui/dialogs/qcolordialog_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/dialogs/qcolordialog_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -318,7 +318,7 @@ QT_USE_NAMESPACE
         // It's important that the modal event loop is stopped before
         // we accept/reject QColorDialog, since QColorDialog has its
         // own event loop that needs to be stopped last. 
-        [NSApp stopModalWithCode:code];
+        [[NSApplication sharedApplication] stopModalWithCode:code];
     } else {
         // Since we are not in a modal event loop, we can safely close
         // down QColorDialog
@@ -350,7 +350,7 @@ QT_USE_NAMESPACE
     while (!modalEnded) {
 #ifndef QT_NO_EXCEPTIONS
         @try {
-            [NSApp runModalForWindow:mColorPanel];
+            [[NSApplication sharedApplication] runModalForWindow:mColorPanel];
             modalEnded = true;
         } @catch (NSException *) {
             // For some reason, NSColorPanel throws an exception when
@@ -358,7 +358,7 @@ QT_USE_NAMESPACE
             // palette (tab three).
         }
 #else
-        [NSApp runModalForWindow:mColorPanel];
+        [[NSApplication sharedApplication] runModalForWindow:mColorPanel];
         modalEnded = true;
 #endif
     }
@@ -469,10 +469,10 @@ void QColorDialogPrivate::mac_nativeDial
     // Do a queued meta-call to open the native modal dialog so it opens after the new
     // event loop has started to execute (in QDialog::exec). Using a timer rather than
     // a queued meta call is intentional to ensure that the call is only delivered when
-    // [NSApp run] runs (timers are handeled special in cocoa). If NSApp is not
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
     // running (which is the case if e.g a top-most QEventLoop has been
     // interrupted, and the second-most event loop has not yet been reactivated (regardless
-    // if [NSApp run] is still on the stack)), showing a native modal dialog will fail.
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
     if (delegate){
         Q_Q(QColorDialog);
         QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
diff -rupN qt-orig/src/gui/dialogs/qfiledialog_mac.mm qt-patched/src/gui/dialogs/qfiledialog_mac.mm
--- qt-orig/src/gui/dialogs/qfiledialog_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/dialogs/qfiledialog_mac.mm	2015-03-22 09:27:57.000000000 +0000
@@ -229,7 +229,7 @@ QT_USE_NAMESPACE
     if ([mSavePanel respondsToSelector:@selector(close)])
         [mSavePanel close];
     if ([mSavePanel isSheet])
-        [NSApp endSheet: mSavePanel];
+        [[NSApplication sharedApplication] endSheet: mSavePanel];
 }
 
 - (void)showModelessPanel
@@ -297,6 +297,7 @@ QT_USE_NAMESPACE
     CFURLRef url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)filename, kCFURLPOSIXPathStyle, isDir);
     CFBooleanRef isHidden;
     Boolean errorOrHidden = false;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
     if (!CFURLCopyResourcePropertyForKey(url, kCFURLIsHiddenKey, &isHidden, NULL)) {
         errorOrHidden = true;
     } else {
@@ -304,6 +305,7 @@ QT_USE_NAMESPACE
             errorOrHidden = true;
         CFRelease(isHidden);
     }
+#endif
     CFRelease(url);
     return errorOrHidden;
 #else
@@ -1162,10 +1164,10 @@ void QFileDialogPrivate::mac_nativeDialo
     // Do a queued meta-call to open the native modal dialog so it opens after the new
     // event loop has started to execute (in QDialog::exec). Using a timer rather than
     // a queued meta call is intentional to ensure that the call is only delivered when
-    // [NSApp run] runs (timers are handeled special in cocoa). If NSApp is not
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
     // running (which is the case if e.g a top-most QEventLoop has been
     // interrupted, and the second-most event loop has not yet been reactivated (regardless
-    // if [NSApp run] is still on the stack)), showing a native modal dialog will fail.
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
     if (nativeDialogInUse){
         Q_Q(QFileDialog);
         QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
diff -rupN qt-orig/src/gui/dialogs/qfiledialog_mac.mm.orig qt-patched/src/gui/dialogs/qfiledialog_mac.mm.orig
--- qt-orig/src/gui/dialogs/qfiledialog_mac.mm.orig	1970-01-01 01:00:00.000000000 +0100
+++ qt-patched/src/gui/dialogs/qfiledialog_mac.mm.orig	2015-03-22 09:25:56.000000000 +0000
@@ -0,0 +1,1207 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfiledialog.h"
+
+#ifndef QT_NO_FILEDIALOG
+
+/*****************************************************************************
+  QFileDialog debug facilities
+ *****************************************************************************/
+//#define DEBUG_FILEDIALOG_FILTERS
+
+#include <qapplication.h>
+#include <private/qapplication_p.h>
+#include <private/qfiledialog_p.h>
+#include <private/qt_mac_p.h>
+#include <private/qt_cocoa_helpers_mac_p.h>
+#include <qregexp.h>
+#include <qbuffer.h>
+#include <qdebug.h>
+#include <qstringlist.h>
+#include <qaction.h>
+#include <qtextcodec.h>
+#include <qvarlengtharray.h>
+#include <qdesktopwidget.h>
+#include <stdlib.h>
+#include <qabstracteventdispatcher.h>
+#import <AppKit/NSSavePanel.h>
+#include "ui_qfiledialog.h"
+
+QT_BEGIN_NAMESPACE
+
+extern QStringList qt_make_filter_list(const QString &filter); // qfiledialog.cpp
+extern QStringList qt_clean_filter_list(const QString &filter); // qfiledialog.cpp
+extern const char *qt_file_dialog_filter_reg_exp; // qfiledialog.cpp
+extern bool qt_mac_is_macsheet(const QWidget *w); // qwidget_mac.mm
+
+QT_END_NAMESPACE
+
+QT_FORWARD_DECLARE_CLASS(QFileDialogPrivate)
+QT_FORWARD_DECLARE_CLASS(QString)
+QT_FORWARD_DECLARE_CLASS(QStringList)
+QT_FORWARD_DECLARE_CLASS(QWidget)
+QT_FORWARD_DECLARE_CLASS(QAction)
+QT_FORWARD_DECLARE_CLASS(QFileInfo)
+QT_USE_NAMESPACE
+
+@class QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate);
+
+@interface QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate)
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
+    : NSObject<NSOpenSavePanelDelegate>
+#else
+    : NSObject
+#endif
+{
+    @public
+    NSOpenPanel *mOpenPanel;
+    NSSavePanel *mSavePanel;
+    NSView *mAccessoryView;
+    NSPopUpButton *mPopUpButton;
+    NSTextField *mTextField;
+    QFileDialogPrivate *mPriv;
+    NSString *mCurrentDir;
+    bool mConfirmOverwrite;
+    int mReturnCode;
+
+    QT_PREPEND_NAMESPACE(QFileDialog::AcceptMode) mAcceptMode;
+    QT_PREPEND_NAMESPACE(QDir::Filters) *mQDirFilter;
+    QT_PREPEND_NAMESPACE(QFileDialog::FileMode) mFileMode;
+    QT_PREPEND_NAMESPACE(QFileDialog::Options) *mFileOptions;
+
+    QString *mLastFilterCheckPath;
+    QString *mCurrentSelection;
+    QStringList *mQDirFilterEntryList;
+    QStringList *mNameFilterDropDownList;
+    QStringList *mSelectedNameFilter;
+}
+
+- (NSString *)strip:(const QString &)label;
+- (BOOL)panel:(id)sender shouldShowFilename:(NSString *)filename;
+- (void)filterChanged:(id)sender;
+- (void)showModelessPanel;
+- (BOOL)runApplicationModalPanel;
+- (void)showWindowModalSheet:(QWidget *)docWidget;
+- (void)updateProperties;
+- (QStringList)acceptableExtensionsForSave;
+- (QString)removeExtensions:(const QString &)filter;
+- (void)createTextField;
+- (void)createPopUpButton:(const QString &)selectedFilter hideDetails:(BOOL)hideDetails;
+- (QStringList)findStrippedFilterWithVisualFilterName:(QString)name;
+- (void)createAccessory;
+
+@end
+
+@implementation QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate)
+
+- (id)initWithAcceptMode:(QT_PREPEND_NAMESPACE(QFileDialog::AcceptMode))acceptMode
+    title:(const QString &)title
+    hideNameFilterDetails:(bool)hideNameFilterDetails
+    qDirFilter:(QT_PREPEND_NAMESPACE(QDir::Filters))qDirFilter
+    fileOptions:(QT_PREPEND_NAMESPACE(QFileDialog::Options))fileOptions
+    fileMode:(QT_PREPEND_NAMESPACE(QFileDialog::FileMode))fileMode
+    selectFile:(const QString &)selectFile
+    confirmOverwrite:(bool)confirm
+    priv:(QFileDialogPrivate *)priv
+{
+    self = [super init];
+
+    mAcceptMode = acceptMode;
+    if (mAcceptMode == QT_PREPEND_NAMESPACE(QFileDialog::AcceptOpen)){
+        mOpenPanel = [NSOpenPanel openPanel];
+        mSavePanel = mOpenPanel;
+    } else {
+        mSavePanel = [NSSavePanel savePanel];
+        mOpenPanel = 0;
+    }
+
+    if ([mSavePanel respondsToSelector:@selector(setLevel:)])
+        [mSavePanel setLevel:NSModalPanelWindowLevel];
+    [mSavePanel setDelegate:self];
+    mQDirFilter = new QT_PREPEND_NAMESPACE(QDir::Filters)(qDirFilter);
+    mFileOptions = new QT_PREPEND_NAMESPACE(QFileDialog::Options)(fileOptions);
+    mFileMode = fileMode;
+    mConfirmOverwrite = confirm;
+    mReturnCode = -1;
+    mPriv = priv;
+    mLastFilterCheckPath = new QString;
+    mQDirFilterEntryList = new QStringList;
+    mNameFilterDropDownList = new QStringList(priv->nameFilters);
+    QString selectedVisualNameFilter = priv->qFileDialogUi->fileTypeCombo->currentText();
+    mSelectedNameFilter = new QStringList([self findStrippedFilterWithVisualFilterName:selectedVisualNameFilter]);
+
+    QFileInfo sel(selectFile);
+    if (sel.isDir() && !sel.isBundle()){
+        mCurrentDir = [qt_mac_QStringToNSString(sel.absoluteFilePath()) retain];
+        mCurrentSelection = new QString;
+    } else {
+        mCurrentDir = [qt_mac_QStringToNSString(sel.absolutePath()) retain];
+        mCurrentSelection = new QString(sel.absoluteFilePath());
+    }
+
+    [mSavePanel setTitle:qt_mac_QStringToNSString(title)];
+    [self createPopUpButton:selectedVisualNameFilter hideDetails:hideNameFilterDetails];
+    [self createTextField];
+    [self createAccessory];
+    [mSavePanel setAccessoryView:mNameFilterDropDownList->size() > 1 ? mAccessoryView : nil];
+
+    if (mPriv){
+        [mSavePanel setPrompt:[self strip:mPriv->acceptLabel]];
+        if (mPriv->fileNameLabelExplicitlySat)
+            [mSavePanel setNameFieldLabel:[self strip:mPriv->qFileDialogUi->fileNameLabel->text()]];
+    }
+
+    [self updateProperties];
+    [mSavePanel retain];
+    return self;
+}
+
+- (void)dealloc
+{
+    delete mQDirFilter;
+    delete mFileOptions;
+    delete mLastFilterCheckPath;
+    delete mQDirFilterEntryList;
+    delete mNameFilterDropDownList;
+    delete mSelectedNameFilter;
+    delete mCurrentSelection;
+
+    if ([mSavePanel respondsToSelector:@selector(orderOut:)])
+        [mSavePanel orderOut:mSavePanel];
+    [mSavePanel setAccessoryView:nil];
+    [mPopUpButton release];
+    [mTextField release];
+    [mAccessoryView release];
+    [mSavePanel setDelegate:nil];
+    [mSavePanel release];
+    [mCurrentDir release];
+    [super dealloc];
+}
+
+- (NSString *)strip:(const QString &)label
+{
+    QAction a(label, 0);
+    return qt_mac_QStringToNSString(a.iconText());
+}
+
+- (void)closePanel
+{
+    *mCurrentSelection = QT_PREPEND_NAMESPACE(qt_mac_NSStringToQString)([mSavePanel filename]);
+    if ([mSavePanel respondsToSelector:@selector(close)])
+        [mSavePanel close];
+    if ([mSavePanel isSheet])
+        [[NSApplication sharedApplication] endSheet: mSavePanel];
+}
+
+- (void)showModelessPanel
+{
+    if (mOpenPanel){
+        QFileInfo info(*mCurrentSelection);
+        NSString *filename = QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(info.fileName());
+        NSString *filepath = QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(info.filePath());
+        bool selectable = (mAcceptMode == QFileDialog::AcceptSave)
+            || [self panel:nil shouldShowFilename:filepath];
+        [mOpenPanel 
+            beginForDirectory:mCurrentDir
+            file:selectable ? filename : nil
+            types:nil
+            modelessDelegate:self
+            didEndSelector:@selector(openPanelDidEnd:returnCode:contextInfo:)
+            contextInfo:nil];
+    }
+}
+
+- (BOOL)runApplicationModalPanel
+{
+    QFileInfo info(*mCurrentSelection);
+    NSString *filename = QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(info.fileName());
+    NSString *filepath = QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(info.filePath());
+    bool selectable = (mAcceptMode == QFileDialog::AcceptSave)
+        || [self panel:nil shouldShowFilename:filepath];
+    mReturnCode = [mSavePanel 
+        runModalForDirectory:mCurrentDir
+        file:selectable ? filename : @"untitled"];
+
+    QAbstractEventDispatcher::instance()->interrupt();
+    return (mReturnCode == NSOKButton);
+}
+
+- (QT_PREPEND_NAMESPACE(QDialog::DialogCode))dialogResultCode
+{
+    return (mReturnCode == NSOKButton) ? QT_PREPEND_NAMESPACE(QDialog::Accepted) : QT_PREPEND_NAMESPACE(QDialog::Rejected);
+}
+
+- (void)showWindowModalSheet:(QWidget *)docWidget
+{
+    Q_UNUSED(docWidget);
+    QFileInfo info(*mCurrentSelection);
+    NSString *filename = QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(info.fileName());
+    NSString *filepath = QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(info.filePath());
+    bool selectable = (mAcceptMode == QFileDialog::AcceptSave)
+        || [self panel:nil shouldShowFilename:filepath];
+    [mSavePanel 
+        beginSheetForDirectory:mCurrentDir
+        file:selectable ? filename : nil
+#ifdef QT_MAC_USE_COCOA
+        modalForWindow:QT_PREPEND_NAMESPACE(qt_mac_window_for)(docWidget)
+#else
+        modalForWindow:nil
+#endif
+        modalDelegate:self
+        didEndSelector:@selector(openPanelDidEnd:returnCode:contextInfo:)
+        contextInfo:nil];
+}
+
+- (BOOL)isHiddenFile:(NSString *)filename isDir:(BOOL)isDir
+{
+#ifdef QT_MAC_USE_COCOA
+    CFURLRef url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)filename, kCFURLPOSIXPathStyle, isDir);
+    CFBooleanRef isHidden;
+    Boolean errorOrHidden = false;
+    if (!CFURLCopyResourcePropertyForKey(url, kCFURLIsHiddenKey, &isHidden, NULL)) {
+        errorOrHidden = true;
+    } else {
+        if (CFBooleanGetValue(isHidden))
+            errorOrHidden = true;
+        CFRelease(isHidden);
+    }
+    CFRelease(url);
+    return errorOrHidden;
+#else
+    Q_UNUSED(filename);
+    Q_UNUSED(isDir);
+    return false;
+#endif
+}
+
+- (BOOL)panel:(id)sender shouldShowFilename:(NSString *)filename
+{
+    Q_UNUSED(sender);
+
+    if ([filename length] == 0)
+        return NO;
+
+    // Always accept directories regardless of their names (unless it is a bundle):
+    NSFileManager *fm = [NSFileManager defaultManager];
+    NSDictionary *fileAttrs = [fm attributesOfItemAtPath:filename error:nil];
+    if (!fileAttrs)
+        return NO; // Error accessing the file means 'no'.
+    NSString *fileType = [fileAttrs fileType];
+    bool isDir = [fileType isEqualToString:NSFileTypeDirectory];
+    if (isDir) {
+        if ([mSavePanel treatsFilePackagesAsDirectories] == NO) {
+            if ([[NSWorkspace sharedWorkspace] isFilePackageAtPath:filename] == NO)
+                return YES;
+        }
+    }
+
+    QString qtFileName
+        = QFileInfo(QT_PREPEND_NAMESPACE(qt_mac_NSStringToQString)(filename)).fileName();
+    // No filter means accept everything
+    bool nameMatches = mSelectedNameFilter->isEmpty();
+    // Check if the current file name filter accepts the file:
+    for (int i = 0; !nameMatches && i < mSelectedNameFilter->size(); ++i) {
+        if (QDir::match(mSelectedNameFilter->at(i), qtFileName))
+            nameMatches = true;
+    }
+    if (!nameMatches)
+        return NO;
+
+    QDir::Filters filter = *mQDirFilter;
+    if ((!(filter & (QDir::Dirs | QDir::AllDirs)) && isDir)
+        || (!(filter & QDir::Files) && [fileType isEqualToString:NSFileTypeRegular])
+        || ((filter & QDir::NoSymLinks) && [fileType isEqualToString:NSFileTypeSymbolicLink]))
+        return NO;
+
+    bool filterPermissions = ((filter & QDir::PermissionMask)
+                              && (filter & QDir::PermissionMask) != QDir::PermissionMask);
+    if (filterPermissions) {
+        if ((!(filter & QDir::Readable) && [fm isReadableFileAtPath:filename])
+            || (!(filter & QDir::Writable) && [fm isWritableFileAtPath:filename])
+            || (!(filter & QDir::Executable) && [fm isExecutableFileAtPath:filename]))
+            return NO;
+    }
+    if (!(filter & QDir::Hidden)
+        && (qtFileName.startsWith(QLatin1Char('.')) || [self isHiddenFile:filename isDir:isDir]))
+            return NO;
+
+    return YES;
+}
+
+- (NSString *)panel:(id)sender userEnteredFilename:(NSString *)filename confirmed:(BOOL)okFlag
+{
+    Q_UNUSED(sender);
+    if (!okFlag)
+        return filename;
+    if (mConfirmOverwrite)
+        return filename;
+
+    // User has clicked save, and no overwrite confirmation should occur.
+    // To get the latter, we need to change the name we return (hence the prefix):
+    return [@"___qt_very_unlikely_prefix_" stringByAppendingString:filename];
+}
+
+- (void)setNameFilters:(const QStringList &)filters hideDetails:(BOOL)hideDetails
+{
+    [mPopUpButton removeAllItems];
+    *mNameFilterDropDownList = filters;
+    if (filters.size() > 0){
+        for (int i=0; i<filters.size(); ++i) {
+            QString filter = hideDetails ? [self removeExtensions:filters.at(i)] : filters.at(i);
+            [mPopUpButton addItemWithTitle:QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(filter)];
+        }
+        [mPopUpButton selectItemAtIndex:0];
+        [mSavePanel setAccessoryView:mAccessoryView];
+    } else
+        [mSavePanel setAccessoryView:nil];
+
+    [self filterChanged:self];
+}
+
+- (void)filterChanged:(id)sender
+{
+    // This mDelegate function is called when the _name_ filter changes.
+    Q_UNUSED(sender);
+    QString selection = mNameFilterDropDownList->value([mPopUpButton indexOfSelectedItem]);
+    *mSelectedNameFilter = [self findStrippedFilterWithVisualFilterName:selection];
+    if ([mSavePanel respondsToSelector:@selector(validateVisibleColumns)])
+        [mSavePanel validateVisibleColumns];
+    [self updateProperties];
+    if (mPriv)
+        mPriv->QNSOpenSavePanelDelegate_filterSelected([mPopUpButton indexOfSelectedItem]);
+}
+
+- (QString)currentNameFilter
+{
+    return mNameFilterDropDownList->value([mPopUpButton indexOfSelectedItem]);
+}
+
+- (QStringList)selectedFiles
+{
+    if (mOpenPanel)
+        return QT_PREPEND_NAMESPACE(qt_mac_NSArrayToQStringList)([mOpenPanel filenames]);
+    else{
+        QStringList result;
+        QString filename = QT_PREPEND_NAMESPACE(qt_mac_NSStringToQString)([mSavePanel filename]);
+        result << filename.remove(QLatin1String("___qt_very_unlikely_prefix_"));
+        return result;
+    }
+}
+
+- (void)updateProperties
+{
+    // Call this functions if mFileMode, mFileOptions,
+    // mNameFilterDropDownList or mQDirFilter changes.
+    // The savepanel does not contain the neccessary functions for this.
+    bool chooseFilesOnly = mFileMode == QT_PREPEND_NAMESPACE(QFileDialog::ExistingFile)
+        || mFileMode == QT_PREPEND_NAMESPACE(QFileDialog::ExistingFiles);
+    bool chooseDirsOnly = mFileMode == QT_PREPEND_NAMESPACE(QFileDialog::Directory)
+        || mFileMode == QT_PREPEND_NAMESPACE(QFileDialog::DirectoryOnly)
+        || *mFileOptions & QT_PREPEND_NAMESPACE(QFileDialog::ShowDirsOnly);
+
+    [mOpenPanel setCanChooseFiles:!chooseDirsOnly];
+    [mOpenPanel setCanChooseDirectories:!chooseFilesOnly];
+    [mSavePanel setCanCreateDirectories:!(*mFileOptions & QT_PREPEND_NAMESPACE(QFileDialog::ReadOnly))];
+    [mOpenPanel setAllowsMultipleSelection:(mFileMode == QT_PREPEND_NAMESPACE(QFileDialog::ExistingFiles))];
+    [mOpenPanel setResolvesAliases:!(*mFileOptions & QT_PREPEND_NAMESPACE(QFileDialog::DontResolveSymlinks))];
+
+    QStringList ext = [self acceptableExtensionsForSave];
+    if (mPriv && !ext.isEmpty() && !mPriv->defaultSuffix.isEmpty())
+        ext.prepend(mPriv->defaultSuffix);
+    [mSavePanel setAllowedFileTypes:ext.isEmpty() ? nil : QT_PREPEND_NAMESPACE(qt_mac_QStringListToNSMutableArray(ext))];
+
+    if ([mSavePanel respondsToSelector:@selector(isVisible)] && [mSavePanel isVisible])
+    {
+        if ([mOpenPanel respondsToSelector:@selector(validateVisibleColumns)])
+            [mOpenPanel validateVisibleColumns];
+    }
+}
+
+- (void)panelSelectionDidChange:(id)sender
+{
+    Q_UNUSED(sender);
+    if (mPriv) {
+        QString selection = QT_PREPEND_NAMESPACE(qt_mac_NSStringToQString([mSavePanel filename]));
+        if (selection != mCurrentSelection) {
+            *mCurrentSelection = selection;
+            mPriv->QNSOpenSavePanelDelegate_selectionChanged(selection);
+        }
+    }
+}
+
+- (void)openPanelDidEnd:(NSOpenPanel *)panel returnCode:(int)returnCode  contextInfo:(void *)contextInfo
+{
+    Q_UNUSED(panel);
+    Q_UNUSED(contextInfo);
+    mReturnCode = returnCode;
+    if (mPriv)
+        mPriv->QNSOpenSavePanelDelegate_panelClosed(returnCode == NSOKButton);
+}
+
+- (void)panel:(id)sender directoryDidChange:(NSString *)path
+{
+    Q_UNUSED(sender);
+    if (!mPriv)
+        return;
+    if ([path isEqualToString:mCurrentDir])
+        return;
+
+    if ([mSavePanel respondsToSelector:@selector(isVisible)] && ![mSavePanel isVisible])
+        return;
+    [mCurrentDir release];
+    mCurrentDir = [path retain];
+    mPriv->QNSOpenSavePanelDelegate_directoryEntered(QT_PREPEND_NAMESPACE(qt_mac_NSStringToQString(mCurrentDir)));
+}
+
+/*
+    Returns a list of extensions (e.g. "png", "jpg", "gif")
+    for the current name filter. If a filter do not conform
+    to the format *.xyz or * or *.*, an empty list
+    is returned meaning accept everything.
+*/
+- (QStringList)acceptableExtensionsForSave
+{
+    QStringList result;
+    for (int i=0; i<mSelectedNameFilter->count(); ++i) {
+        const QString &filter = mSelectedNameFilter->at(i);
+        if (filter.startsWith(QLatin1String("*."))
+                && !filter.contains(QLatin1Char('?'))
+                && filter.count(QLatin1Char('*')) == 1) {
+            result += filter.mid(2);
+        } else {
+            return QStringList(); // Accept everything
+        }
+    }
+    return result;
+}
+
+- (QString)removeExtensions:(const QString &)filter
+{
+    QRegExp regExp(QT_PREPEND_NAMESPACE(QString::fromLatin1)(QT_PREPEND_NAMESPACE(qt_file_dialog_filter_reg_exp)));
+    if (regExp.indexIn(filter) != -1)
+        return regExp.cap(1).trimmed();
+    return filter;
+}
+
+- (void)createTextField
+{
+    NSRect textRect = { { 0.0, 3.0 }, { 100.0, 25.0 } };
+    mTextField = [[NSTextField alloc] initWithFrame:textRect];
+    [[mTextField cell] setFont:[NSFont systemFontOfSize:
+            [NSFont systemFontSizeForControlSize:NSRegularControlSize]]];
+    [mTextField setAlignment:NSRightTextAlignment];
+    [mTextField setEditable:false];
+    [mTextField setSelectable:false];
+    [mTextField setBordered:false];
+    [mTextField setDrawsBackground:false];
+    if (mPriv){
+        [mTextField setStringValue:[self strip:mPriv->qFileDialogUi->fileTypeLabel->text()]];
+    } else
+        [mTextField setStringValue:QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(QT_PREPEND_NAMESPACE(QFileDialog::tr)("Files of type:"))];
+}
+
+- (void)createPopUpButton:(const QString &)selectedFilter hideDetails:(BOOL)hideDetails
+{
+    NSRect popUpRect = { { 100.0, 5.0 }, { 250.0, 25.0 } };
+    mPopUpButton = [[NSPopUpButton alloc] initWithFrame:popUpRect pullsDown:NO];
+    [mPopUpButton setTarget:self];
+    [mPopUpButton setAction:@selector(filterChanged:)];
+
+    if (mNameFilterDropDownList->size() > 0) {
+        int filterToUse = -1;
+        for (int i=0; i<mNameFilterDropDownList->size(); ++i) {
+            QString currentFilter = mNameFilterDropDownList->at(i);
+            if (selectedFilter == currentFilter ||
+                (filterToUse == -1 && currentFilter.startsWith(selectedFilter)))
+                filterToUse = i;
+            QString filter = hideDetails ? [self removeExtensions:currentFilter] : currentFilter;
+            [mPopUpButton addItemWithTitle:QT_PREPEND_NAMESPACE(qt_mac_QStringToNSString)(filter)];
+        }
+        if (filterToUse != -1)
+            [mPopUpButton selectItemAtIndex:filterToUse];
+    }
+}
+
+- (QStringList) findStrippedFilterWithVisualFilterName:(QString)name
+{
+    for (int i=0; i<mNameFilterDropDownList->size(); ++i) {
+        if (mNameFilterDropDownList->at(i).startsWith(name))
+            return qt_clean_filter_list(mNameFilterDropDownList->at(i));
+    }
+    return QStringList();
+}
+
+- (void)createAccessory
+{
+    NSRect accessoryRect = { { 0.0, 0.0 }, { 450.0, 33.0 } };
+    mAccessoryView = [[NSView alloc] initWithFrame:accessoryRect];
+    [mAccessoryView addSubview:mTextField];
+    [mAccessoryView addSubview:mPopUpButton];
+}
+
+@end
+
+QT_BEGIN_NAMESPACE
+
+void QFileDialogPrivate::QNSOpenSavePanelDelegate_selectionChanged(const QString &newPath)
+{
+    emit q_func()->currentChanged(newPath);
+}
+
+void QFileDialogPrivate::QNSOpenSavePanelDelegate_panelClosed(bool accepted)
+{
+    if (accepted)
+        q_func()->accept();
+    else
+        q_func()->reject();
+}
+
+void QFileDialogPrivate::QNSOpenSavePanelDelegate_directoryEntered(const QString &newDir)
+{
+    setLastVisitedDirectory(newDir);
+    emit q_func()->directoryEntered(newDir);
+}
+
+void QFileDialogPrivate::QNSOpenSavePanelDelegate_filterSelected(int menuIndex)
+{
+    emit q_func()->filterSelected(nameFilters.at(menuIndex));
+}
+
+void QFileDialogPrivate::setDirectory_sys(const QString &directory)
+{
+#ifndef QT_MAC_USE_COCOA
+    if (directory == mCurrentLocation)
+        return;
+    mCurrentLocation = directory;
+    emit q_func()->directoryEntered(mCurrentLocation);
+
+    FSRef fsRef;
+    if (qt_mac_create_fsref(directory, &fsRef) == noErr) {
+        AEDesc desc;
+        if (AECreateDesc(typeFSRef, &fsRef, sizeof(FSRef), &desc) == noErr)
+            NavCustomControl(mDialog, kNavCtlSetLocation, (void*)&desc);
+    }
+#else
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    [delegate->mSavePanel setDirectory:qt_mac_QStringToNSString(directory)];
+#endif
+}
+
+QString QFileDialogPrivate::directory_sys() const
+{
+#ifndef QT_MAC_USE_COCOA
+    return mCurrentLocation;
+#else
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    return qt_mac_NSStringToQString([delegate->mSavePanel directory]);
+#endif
+}
+
+void QFileDialogPrivate::selectFile_sys(const QString &filename)
+{
+    QString filePath = filename;
+    if (QDir::isRelativePath(filePath))
+        filePath = QFileInfo(directory_sys(), filePath).filePath();
+
+#ifndef QT_MAC_USE_COCOA
+    // Update the selection list immidiatly, so
+    // subsequent calls to selectedFiles() gets correct:
+    mCurrentSelectionList.clear();
+    mCurrentSelectionList << filename;
+    if (mCurrentSelection != filename){
+        mCurrentSelection = filename;
+        emit q_func()->currentChanged(mCurrentSelection);
+    }
+
+    AEDescList descList;
+    if (AECreateList(0, 0, false, &descList) != noErr)
+        return;
+
+    FSRef fsRef;
+    if (qt_mac_create_fsref(filePath, &fsRef) == noErr) {
+        AEDesc desc;
+        if (AECreateDesc(typeFSRef, &fsRef, sizeof(FSRef), &desc) == noErr){
+            if (AEPutDesc(&descList, 0, &desc) == noErr)
+                NavCustomControl(mDialog, kNavCtlSetSelection, (void*)&descList);
+        }
+    }
+
+    // Type the file name into the save dialog's text field:
+    UInt8 *strBuffer = (UInt8 *)malloc(1024);
+    qt_mac_to_pascal_string(QFileInfo(filename).fileName(), strBuffer);
+    NavCustomControl(mDialog, kNavCtlSetEditFileName, strBuffer);
+    free(strBuffer);
+#else
+    // There seems to no way to select a file once the dialog is running.
+    // So do the next best thing, set the file's directory:
+    setDirectory_sys(QFileInfo(filePath).absolutePath());
+#endif
+}
+
+QStringList QFileDialogPrivate::selectedFiles_sys() const
+{
+#ifndef QT_MAC_USE_COCOA
+    if (q_func()->acceptMode() == QFileDialog::AcceptOpen){
+        return mCurrentSelectionList;
+    } else {
+        return QStringList() << mCurrentLocation + QLatin1Char('/')
+                                + QCFString::toQString(NavDialogGetSaveFileName(mDialog));
+    }
+#else
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    return [delegate selectedFiles];
+#endif
+}
+
+void QFileDialogPrivate::setNameFilters_sys(const QStringList &filters)
+{
+#ifndef QT_MAC_USE_COCOA
+    Q_UNUSED(filters);
+#else
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    bool hideDetails = q_func()->testOption(QFileDialog::HideNameFilterDetails);
+    [delegate setNameFilters:filters hideDetails:hideDetails];
+#endif
+}
+
+void QFileDialogPrivate::setFilter_sys()
+{
+#ifndef QT_MAC_USE_COCOA
+#else
+    Q_Q(QFileDialog);
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    *(delegate->mQDirFilter) = model->filter();
+    delegate->mFileMode = fileMode;
+    [delegate->mSavePanel setTitle:qt_mac_QStringToNSString(q->windowTitle())];
+    [delegate->mSavePanel setPrompt:[delegate strip:acceptLabel]];
+    if (fileNameLabelExplicitlySat)
+        [delegate->mSavePanel setNameFieldLabel:[delegate strip:qFileDialogUi->fileNameLabel->text()]];
+
+    [delegate updateProperties];
+#endif
+}
+
+void QFileDialogPrivate::selectNameFilter_sys(const QString &filter)
+{
+    int index = nameFilters.indexOf(filter);
+    if (index != -1) {
+#ifndef QT_MAC_USE_COCOA
+        NavMenuItemSpec navSpec;
+        bzero(&navSpec, sizeof(NavMenuItemSpec));
+        navSpec.menuType = index;
+        NavCustomControl(mDialog, kNavCtlSelectCustomType, &navSpec);
+#else
+        QMacCocoaAutoReleasePool pool;
+        QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+        [delegate->mPopUpButton selectItemAtIndex:index];
+        [delegate filterChanged:nil];
+#endif
+    }
+}
+
+QString QFileDialogPrivate::selectedNameFilter_sys() const
+{
+#ifndef QT_MAC_USE_COCOA
+    int index = filterInfo.currentSelection;
+#else
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    int index = [delegate->mPopUpButton indexOfSelectedItem];
+#endif
+    return index != -1 ? nameFilters.at(index) : QString();
+}
+
+void QFileDialogPrivate::deleteNativeDialog_sys()
+{
+#ifndef QT_MAC_USE_COCOA
+    if (mDialog)
+        NavDialogDispose(mDialog);
+    mDialog = 0;
+    mDialogStarted = false;
+#else
+    QMacCocoaAutoReleasePool pool;
+    [reinterpret_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate) release];
+    mDelegate = 0;
+#endif
+    nativeDialogInUse = false;
+}
+
+bool QFileDialogPrivate::setVisible_sys(bool visible)
+{
+    Q_Q(QFileDialog);
+    if (!visible == q->isHidden())
+        return false;
+
+    if (q->windowFlags() & Qt::WindowStaysOnTopHint) {
+        // The native file dialog tries all it can to stay
+        // on the NSModalPanel level. And it might also show
+        // its own "create directory" dialog that we cannot control.
+        // So we need to use the non-native version in this case...
+        return false;
+    }
+
+#ifndef QT_MAC_USE_COCOA
+    return visible ? showCarbonNavServicesDialog() : hideCarbonNavServicesDialog();
+#else
+    return visible ? showCocoaFilePanel() : hideCocoaFilePanel();
+#endif
+}
+
+#ifndef QT_MAC_USE_COCOA
+Boolean QFileDialogPrivate::qt_mac_filedialog_filter_proc(AEDesc *theItem, void *info,
+                                                                 void *data, NavFilterModes)
+{
+    QFileDialogPrivate *fileDialogPrivate = static_cast<QFileDialogPrivate *>(data);
+
+    if (!fileDialogPrivate || fileDialogPrivate->filterInfo.filters.isEmpty()
+        || (fileDialogPrivate->filterInfo.currentSelection < 0
+                && fileDialogPrivate->filterInfo.currentSelection
+                        >= fileDialogPrivate->filterInfo.filters.size()))
+        return true;
+
+    NavFileOrFolderInfo *theInfo = static_cast<NavFileOrFolderInfo *>(info);
+    QString file;
+    QString path;
+    const QtMacFilterName &fn
+           = fileDialogPrivate->filterInfo.filters.at(fileDialogPrivate->filterInfo.currentSelection);
+    if (theItem->descriptorType == typeFSRef) {
+        FSRef ref;
+        AEGetDescData(theItem, &ref, sizeof(ref));
+        UInt8 str_buffer[1024];
+        FSRefMakePath(&ref, str_buffer, 1024);
+        path = QString::fromUtf8(reinterpret_cast<const char *>(str_buffer));
+        int slsh = path.lastIndexOf(QLatin1Char('/'));
+        if (slsh != -1)
+            file = path.right(path.length() - slsh - 1);
+        else
+            file = path;
+    }
+    QStringList reg = fn.regexp.split(QLatin1String(";"));
+    for (QStringList::const_iterator it = reg.constBegin(); it != reg.constEnd(); ++it) {
+        QRegExp rg(*it, Qt::CaseInsensitive, QRegExp::Wildcard);
+#ifdef DEBUG_FILEDIALOG_FILTERS
+        qDebug("QFileDialogPrivate::qt_mac_filedialog_filter_proc:%d, asked to filter.. %s (%s)", __LINE__,
+                qPrintable(file), qPrintable(*it));
+#endif
+        if (rg.exactMatch(file))
+            return true;
+    }
+
+    if (theInfo->isFolder) {
+        if ([[NSWorkspace sharedWorkspace] isFilePackageAtPath:qt_mac_QStringToNSString(path)])
+            return false;
+        return true;
+    }
+    return false;
+}
+
+void QFileDialogPrivate::qt_mac_filedialog_event_proc(const NavEventCallbackMessage msg,
+        NavCBRecPtr p, NavCallBackUserData data)
+{
+    QFileDialogPrivate *fileDialogPrivate = static_cast<QFileDialogPrivate *>(data);
+
+    switch(msg) {
+    case kNavCBPopupMenuSelect: {
+        NavMenuItemSpec *s = static_cast<NavMenuItemSpec *>(p->eventData.eventDataParms.param);
+        if (int(s->menuType) != fileDialogPrivate->filterInfo.currentSelection) {
+            fileDialogPrivate->filterInfo.currentSelection = s->menuType;
+            emit fileDialogPrivate->q_func()->filterSelected(fileDialogPrivate->nameFilters.at(s->menuType));
+        }
+        if (fileDialogPrivate->acceptMode == QFileDialog::AcceptSave) {
+            QString base = QCFString::toQString(NavDialogGetSaveFileName(p->context));
+            QFileInfo fi(base);
+            base = fi.completeBaseName();
+            const QtMacFilterName &fn = fileDialogPrivate->filterInfo.filters.at(
+                                                       fileDialogPrivate->filterInfo.currentSelection);
+            QStringList reg = fn.regexp.split(QLatin1String(";"), QString::SkipEmptyParts);
+            if (reg.count()) {
+                QString r = reg.first();
+                r  = r.right(r.length()-1);      // Strip the *
+                base += r;                        //"." + QString::number(s->menuType);
+            }
+            NavDialogSetSaveFileName(p->context, QCFString::toCFStringRef(base));
+        }
+#ifdef DEBUG_FILEDIALOG_FILTERS
+        qDebug("QFileDialogPrivate::qt_mac_filedialog_event_proc:%d - Selected a filter: %ld", __LINE__, s->menuType);
+#endif
+        break; }
+    case kNavCBStart:{
+        fileDialogPrivate->mDialogStarted = true;
+        // Set selected file:
+        QModelIndexList indexes = fileDialogPrivate->qFileDialogUi->listView->selectionModel()->selectedRows();
+        QString selected;
+        if (!indexes.isEmpty())
+            selected = indexes.at(0).data(QFileSystemModel::FilePathRole).toString();
+        else
+            selected = fileDialogPrivate->typedFiles().value(0);
+        fileDialogPrivate->selectFile_sys(selected);
+        fileDialogPrivate->selectNameFilter_sys(fileDialogPrivate->qFileDialogUi->fileTypeCombo->currentText());
+        break; }
+    case kNavCBSelectEntry:{
+        // Event: Current selection has changed.
+        QStringList prevSelectionList = fileDialogPrivate->mCurrentSelectionList;
+        fileDialogPrivate->mCurrentSelectionList.clear();
+        QString fileNameToEmit;
+
+        AEDescList *descList = (AEDescList *)p->eventData.eventDataParms.param;
+        // Get the number of files selected:
+        UInt8 strBuffer[1024];
+        long count;
+        OSErr err = AECountItems(descList, &count);
+        if (err != noErr || !count)
+            break;
+
+        for (long index=1; index<=count; ++index) {
+            FSRef ref;
+            err = AEGetNthPtr(descList, index, typeFSRef, 0, 0, &ref, sizeof(ref), 0);
+            if (err != noErr)
+                break;
+            FSRefMakePath(&ref, strBuffer, 1024);
+            QString selected = QString::fromUtf8((const char *)strBuffer);
+            fileDialogPrivate->mCurrentSelectionList << selected;
+            if (!prevSelectionList.contains(selected))
+                fileNameToEmit = selected;
+        }
+
+        if (!fileNameToEmit.isEmpty() && fileNameToEmit != fileDialogPrivate->mCurrentSelection)
+            emit fileDialogPrivate->q_func()->currentChanged(fileNameToEmit);
+        fileDialogPrivate->mCurrentSelection = fileNameToEmit;
+        break; }
+    case kNavCBShowDesktop:
+    case kNavCBNewLocation:{
+        // Event: Current directory has changed.
+        AEDesc *desc = (AEDesc *)p->eventData.eventDataParms.param;
+        FSRef ref;
+        AEGetDescData(desc, &ref, sizeof(ref));
+        UInt8 *strBuffer = (UInt8 *)malloc(1024);
+        FSRefMakePath(&ref, strBuffer, 1024);
+        QString newLocation = QString::fromUtf8((const char *)strBuffer);
+        free(strBuffer);
+        if (fileDialogPrivate->mCurrentLocation != newLocation){
+            fileDialogPrivate->mCurrentLocation = newLocation;
+            QFileDialog::FileMode mode = fileDialogPrivate->fileMode;
+            if (mode == QFileDialog::AnyFile || mode == QFileDialog::ExistingFile
+                    || mode == QFileDialog::ExistingFiles){
+                // When changing directory, the current selection is cleared if
+                // we are supposed to be selecting files only:
+                if (!fileDialogPrivate->mCurrentSelection.isEmpty()){
+                    fileDialogPrivate->mCurrentSelectionList.clear();
+                    fileDialogPrivate->mCurrentSelection.clear();
+                    emit fileDialogPrivate->q_func()->currentChanged(fileDialogPrivate->mCurrentSelection);
+                }
+            }
+            fileDialogPrivate->setLastVisitedDirectory(newLocation);
+            emit fileDialogPrivate->q_func()->directoryEntered(newLocation);
+        }
+        break; }
+    case kNavCBAccept:
+        fileDialogPrivate->mDialogClosed = true;
+        fileDialogPrivate->q_func()->accept();
+        break;
+    case kNavCBCancel:
+        fileDialogPrivate->mDialogClosed = true;
+        fileDialogPrivate->q_func()->reject();
+        break;
+    }
+}
+
+static QFileDialogPrivate::QtMacFilterName qt_mac_extract_filter(const QString &rawFilter, bool showDetails)
+{
+    QFileDialogPrivate::QtMacFilterName ret;
+    ret.filter = rawFilter;
+    QString result = rawFilter;
+    QRegExp r(QString::fromLatin1(qt_file_dialog_filter_reg_exp));
+    int index = r.indexIn(result);
+    if (index >= 0)
+        result = r.cap(2);
+
+    if (showDetails) {
+        ret.description = rawFilter;
+    } else {
+        if (index >= 0)
+            ret.description = r.cap(1).trimmed();
+        if (ret.description.isEmpty())
+            ret.description = result;
+    }
+    ret.regexp = result.replace(QLatin1Char(' '), QLatin1Char(';'));
+    return ret;
+}
+
+static QList<QFileDialogPrivate::QtMacFilterName> qt_mac_make_filters_list(const QString &filter, bool showDetails)
+{
+#ifdef DEBUG_FILEDIALOG_FILTERS
+    qDebug("QFileDialog:%d - Got filter (%s)", __LINE__, filter.latin1());
+#endif
+
+    QList<QFileDialogPrivate::QtMacFilterName> ret;
+    QString f(filter);
+    if (f.isEmpty())
+        f = QFileDialog::tr("All Files (*)");
+    if (f.isEmpty())
+        return ret;
+    QStringList filts = qt_make_filter_list(f);
+    for (QStringList::const_iterator it = filts.constBegin(); it != filts.constEnd(); ++it) {
+        QFileDialogPrivate::QtMacFilterName filter = qt_mac_extract_filter(*it, showDetails);
+#ifdef DEBUG_FILEDIALOG_FILTERS
+        qDebug("QFileDialog:%d Split out filter (%d) '%s' '%s' [%s]", __LINE__, ret.count(),
+                filter->regxp.latin1(), filter->description.latin1(), (*it).latin1());
+#endif
+        ret.append(filter);
+    }
+    return ret;
+}
+
+void QFileDialogPrivate::createNavServicesDialog()
+{
+    Q_Q(QFileDialog);
+    if (mDialog)
+        deleteNativeDialog_sys();
+
+    NavDialogCreationOptions navOptions;
+    NavGetDefaultDialogCreationOptions(&navOptions);
+
+    // Translate QFileDialog settings into NavDialog options:
+    if (qt_mac_is_macsheet(q)) {
+        navOptions.modality = kWindowModalityWindowModal;
+        navOptions.parentWindow = qt_mac_window_for(q->parentWidget());
+    } else if (q->windowModality() ==  Qt::ApplicationModal)
+        navOptions.modality = kWindowModalityAppModal;
+    else
+        navOptions.modality = kWindowModalityNone;
+    navOptions.optionFlags |= kNavSupportPackages;
+    if (q->testOption(QFileDialog::DontConfirmOverwrite))
+        navOptions.optionFlags |= kNavDontConfirmReplacement;
+    if (fileMode != QFileDialog::ExistingFiles)
+        navOptions.optionFlags &= ~kNavAllowMultipleFiles;
+
+    navOptions.windowTitle = QCFString::toCFStringRef(q->windowTitle());
+
+    navOptions.location.h = -1;
+    navOptions.location.v = -1;
+
+    QWidget *parent = q->parentWidget();
+    if (parent && parent->isVisible()) {
+        WindowClass wclass;
+        GetWindowClass(qt_mac_window_for(parent), &wclass);
+        parent = parent->window();
+        QString s = parent->windowTitle();
+        navOptions.clientName = QCFString::toCFStringRef(s);
+    }
+
+    filterInfo.currentSelection = 0;
+    filterInfo.filters = qt_mac_make_filters_list(nameFilters.join(QLatin1String(";;")), q->isNameFilterDetailsVisible());
+    QCFType<CFArrayRef> filterArray;
+    if (filterInfo.filters.size() > 1) {
+        int i = 0;
+        CFStringRef *cfstringArray = static_cast<CFStringRef *>(malloc(sizeof(CFStringRef)
+                                                                   * filterInfo.filters.size()));
+        for (i = 0; i < filterInfo.filters.size(); ++i) {
+            cfstringArray[i] = QCFString::toCFStringRef(filterInfo.filters.at(i).description);
+        }
+        filterArray = CFArrayCreate(kCFAllocatorDefault,
+                        reinterpret_cast<const void **>(cfstringArray), filterInfo.filters.size(),
+                        &kCFTypeArrayCallBacks);
+        navOptions.popupExtension = filterArray;
+        free(cfstringArray);
+    }
+
+    if (q->acceptMode() == QFileDialog::AcceptSave) {
+        if (NavCreatePutFileDialog(&navOptions, 'cute', kNavGenericSignature,
+                    QFileDialogPrivate::qt_mac_filedialog_event_proc, this, &mDialog)) {
+            qDebug("Shouldn't happen %s:%d", __FILE__, __LINE__);
+            return;
+        }
+    } else if (fileMode == QFileDialog::DirectoryOnly || fileMode == QFileDialog::Directory) {
+        if (NavCreateChooseFolderDialog(&navOptions,
+                    QFileDialogPrivate::qt_mac_filedialog_event_proc, 0, this, &mDialog)) {
+            qDebug("Shouldn't happen %s:%d", __FILE__, __LINE__);
+            return;
+        }
+    } else {
+        if (NavCreateGetFileDialog(&navOptions, 0,
+                    QFileDialogPrivate::qt_mac_filedialog_event_proc, 0,
+                    QFileDialogPrivate::qt_mac_filedialog_filter_proc, this, &mDialog)) {
+            qDebug("Shouldn't happen %s:%d", __FILE__, __LINE__);
+            return;
+        }
+    }
+
+    // Set start-up directory:
+    if (mCurrentLocation.isEmpty())
+        mCurrentLocation = rootPath();
+    FSRef fsRef;
+    if (qt_mac_create_fsref(mCurrentLocation, &fsRef) == noErr) {
+        AEDesc desc;
+        if (AECreateDesc(typeFSRef, &fsRef, sizeof(FSRef), &desc) == noErr)
+            NavCustomControl(mDialog, kNavCtlSetLocation, (void*)&desc);
+    }
+}
+
+bool QFileDialogPrivate::showCarbonNavServicesDialog()
+{
+    Q_Q(QFileDialog);
+    if (q->acceptMode() == QFileDialog::AcceptSave && q->windowModality() == Qt::NonModal)
+        return false; // cannot do native no-modal save dialogs.
+    createNavServicesDialog();
+    mDialogClosed = false;
+    if (q->windowModality() != Qt::ApplicationModal)
+        NavDialogRun(mDialog);
+    return true;
+}
+
+bool QFileDialogPrivate::hideCarbonNavServicesDialog()
+{
+    if (!mDialogClosed){
+        mDialogClosed = true;
+        NavCustomControl(mDialog, kNavCtlCancel, 0);
+    }
+    return true;
+}
+
+#else // Cocoa
+
+void QFileDialogPrivate::createNSOpenSavePanelDelegate()
+{
+    Q_Q(QFileDialog);
+    if (mDelegate)
+        return;
+
+    bool selectDir = q->selectedFiles().isEmpty();
+    QString selection(selectDir ? q->directory().absolutePath() : q->selectedFiles().value(0));
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = [[QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) alloc]
+        initWithAcceptMode:acceptMode
+        title:q->windowTitle()
+        hideNameFilterDetails:q->testOption(QFileDialog::HideNameFilterDetails)
+        qDirFilter:model->filter()
+        fileOptions:opts
+        fileMode:fileMode
+        selectFile:selection
+        confirmOverwrite:!q->testOption(QFileDialog::DontConfirmOverwrite)
+        priv:this];
+
+    mDelegate = delegate;
+}
+
+bool QFileDialogPrivate::showCocoaFilePanel()
+{
+    Q_Q(QFileDialog);
+    QMacCocoaAutoReleasePool pool;
+    createNSOpenSavePanelDelegate();
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    if (qt_mac_is_macsheet(q))
+        [delegate showWindowModalSheet:q->parentWidget()];
+    else if (!q->testAttribute(Qt::WA_ShowModal))
+        [delegate showModelessPanel];
+    return true;
+}
+
+bool QFileDialogPrivate::hideCocoaFilePanel()
+{
+    if (!mDelegate){
+        // Nothing to do. We return false to leave the question
+        // open regarding whether or not to go native:
+        return false;
+    } else {
+        QMacCocoaAutoReleasePool pool;
+        QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+        [delegate closePanel];
+        // Even when we hide it, we are still using a
+        // native dialog, so return true:
+        return true;
+    }
+}
+
+#endif
+
+void QFileDialogPrivate::mac_nativeDialogModalHelp()
+{
+    // Do a queued meta-call to open the native modal dialog so it opens after the new
+    // event loop has started to execute (in QDialog::exec). Using a timer rather than
+    // a queued meta call is intentional to ensure that the call is only delivered when
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
+    // running (which is the case if e.g a top-most QEventLoop has been
+    // interrupted, and the second-most event loop has not yet been reactivated (regardless
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
+    if (nativeDialogInUse){
+        Q_Q(QFileDialog);
+        QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
+    }
+}
+
+void QFileDialogPrivate::_q_macRunNativeAppModalPanel()
+{
+    QBoolBlocker nativeDialogOnTop(QApplicationPrivate::native_modal_dialog_active);
+#ifndef QT_MAC_USE_COCOA
+    NavDialogRun(mDialog);
+#else
+    Q_Q(QFileDialog);
+    QMacCocoaAutoReleasePool pool;
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    [delegate runApplicationModalPanel];
+    dialogResultCode_sys() == QDialog::Accepted ? q->accept() : q->reject();
+#endif
+}
+
+QDialog::DialogCode QFileDialogPrivate::dialogResultCode_sys()
+{
+#ifndef QT_MAC_USE_COCOA
+    NavUserAction result = NavDialogGetUserAction(mDialog);
+    if (result == kNavUserActionCancel || result == kNavUserActionNone)
+        return QDialog::Rejected;
+    else
+        return QDialog::Accepted;
+#else
+    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *delegate = static_cast<QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *>(mDelegate);
+    return [delegate dialogResultCode];
+#endif
+}
+
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_FILEDIALOG
+
diff -rupN qt-orig/src/gui/dialogs/qfontdialog_mac.mm qt-patched/src/gui/dialogs/qfontdialog_mac.mm
--- qt-orig/src/gui/dialogs/qfontdialog_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/dialogs/qfontdialog_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -230,7 +230,7 @@ static QFont qfontForCocoaFont(NSFont *c
     mAppModal = true;
     NSWindow *ourPanel = [mStolenContentView window];
     [ourPanel setReleasedWhenClosed:NO];
-    [NSApp runModalForWindow:ourPanel];
+    [[NSApplication sharedApplication] runModalForWindow:ourPanel];
     QAbstractEventDispatcher::instance()->interrupt();
 
     if (mReturnCode == NSOKButton)
@@ -256,7 +256,7 @@ static QFont qfontForCocoaFont(NSFont *c
 
     mAppModal = false;
     NSWindow *ourPanel = [mStolenContentView window];
-    [NSApp beginSheet:ourPanel
+    [[NSApplication sharedApplication] beginSheet:ourPanel
         modalForWindow:window
         modalDelegate:0
         didEndSelector:0
@@ -456,7 +456,7 @@ static QFont qfontForCocoaFont(NSFont *c
 
     if (mAppModal) {
         mReturnCode = code;
-        [NSApp stopModalWithCode:code];
+        [[NSApplication sharedApplication] stopModalWithCode:code];
     } else {
         if (code == NSOKButton)
             mPriv->fontDialog()->accept();
@@ -636,10 +636,10 @@ void QFontDialogPrivate::mac_nativeDialo
     // Do a queued meta-call to open the native modal dialog so it opens after the new
     // event loop has started to execute (in QDialog::exec). Using a timer rather than
     // a queued meta call is intentional to ensure that the call is only delivered when
-    // [NSApp run] runs (timers are handeled special in cocoa). If NSApp is not
+    // [NSApplication run] runs (timers are handeled special in cocoa). If NSApplication is not
     // running (which is the case if e.g a top-most QEventLoop has been
     // interrupted, and the second-most event loop has not yet been reactivated (regardless
-    // if [NSApp run] is still on the stack)), showing a native modal dialog will fail.
+    // if [NSApplication run] is still on the stack)), showing a native modal dialog will fail.
     if (nativeDialogInUse) {
         Q_Q(QFontDialog);
         QTimer::singleShot(1, q, SLOT(_q_macRunNativeAppModalPanel()));
diff -rupN qt-orig/src/gui/kernel/qapplication_mac.mm qt-patched/src/gui/kernel/qapplication_mac.mm
--- qt-orig/src/gui/kernel/qapplication_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qapplication_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -468,7 +468,7 @@ void qt_mac_set_app_icon(const QPixmap &
         image = static_cast<NSImage *>(qt_mac_create_nsimage(pixmap));
     }
 
-    [NSApp setApplicationIconImage:image];
+    [[NSApplication sharedApplication] setApplicationIconImage:image];
     [image release];
 #endif
 }
@@ -750,7 +750,7 @@ void qt_event_request_showsheet(QWidget 
     Q_ASSERT(qt_mac_is_macsheet(w));
 #ifdef QT_MAC_USE_COCOA
     w->repaint();
-    [NSApp beginSheet:qt_mac_window_for(w) modalForWindow:qt_mac_window_for(w->parentWidget())
+    [[NSApplication sharedApplication] beginSheet:qt_mac_window_for(w) modalForWindow:qt_mac_window_for(w->parentWidget())
         modalDelegate:nil didEndSelector:nil contextInfo:0];
 #else
     qt_mac_event_remove(request_showsheet_pending);
@@ -992,7 +992,7 @@ Q_GUI_EXPORT void qt_mac_set_dock_menu(Q
 {
     qt_mac_dock_menu = menu;
 #ifdef QT_MAC_USE_COCOA
-    [NSApp setDockMenu:menu->macMenu()];
+    [[NSApplication sharedApplication] setDockMenu:menu->macMenu()];
 #else
     SetApplicationDockTileMenu(menu->macMenu());
 #endif
@@ -1011,7 +1011,7 @@ void qt_mac_event_release(QWidget *w)
 #ifndef QT_MAC_USE_COCOA
             SetApplicationDockTileMenu(0);
 #else
-            [NSApp setDockMenu:0];
+            [[NSApplication sharedApplication] setDockMenu:0];
 #endif
         }
     }
@@ -1463,7 +1463,7 @@ QWidget *QApplication::topLevelAt(const 
     NSWindowList(windowCount, windowList.data());
     int firstQtWindowFound = -1;
     for (int i = 0; i < windowCount; ++i) {
-        NSWindow *window = [NSApp windowWithWindowNumber:windowList[i]];
+        NSWindow *window = [[NSApplication sharedApplication] windowWithWindowNumber:windowList[i]];
         if (window) {
             QWidget *candidateWindow = [window QT_MANGLE_NAMESPACE(qt_qwidget)];
             if (candidateWindow && firstQtWindowFound == -1)
@@ -3071,7 +3071,7 @@ bool QApplicationPrivate::canQuit()
 #else
     Q_Q(QApplication);
 #ifdef QT_MAC_USE_COCOA
-    [[NSApp mainMenu] cancelTracking];
+    [[[NSApplication sharedApplication] mainMenu] cancelTracking];
 #else
     HiliteMenu(0);
 #endif
@@ -3146,7 +3146,7 @@ void onApplicationChangedActivation( boo
         }
 
         if (!app->activeWindow()) {
-            OSWindowRef wp = [NSApp keyWindow];
+            OSWindowRef wp = [[NSApplication sharedApplication] keyWindow];
             if (QWidget *tmp_w = qt_mac_find_window(wp))
                 app->setActiveWindow(tmp_w);
         }
diff -rupN qt-orig/src/gui/kernel/qapplication_mac.mm.rej qt-patched/src/gui/kernel/qapplication_mac.mm.rej
--- qt-orig/src/gui/kernel/qapplication_mac.mm.rej	1970-01-01 01:00:00.000000000 +0100
+++ qt-patched/src/gui/kernel/qapplication_mac.mm.rej	2015-03-22 09:28:15.000000000 +0000
@@ -0,0 +1,33 @@
+***************
+*** 226,231 ****
+  void onApplicationWindowChangedActivation( QWidget*widget, bool activated );
+  void onApplicationChangedActivation( bool activated );
+  
+  void qt_mac_loadMenuNib(QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *qtMenuLoader)
+  {
+      // Create qt_menu.nib dir in temp.
+--- 226,232 ----
+  void onApplicationWindowChangedActivation( QWidget*widget, bool activated );
+  void onApplicationChangedActivation( bool activated );
+  
++ #ifdef QT_MAC_USE_COCOA
+  void qt_mac_loadMenuNib(QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *qtMenuLoader)
+  {
+      // Create qt_menu.nib dir in temp.
+***************
+*** 258,264 ****
+      if (!ok)
+          qWarning("qt_mac_loadMenuNib: could not instantiate nib");
+  }
+- 
+  
+  static void qt_mac_read_fontsmoothing_settings()
+  {
+--- 259,265 ----
+      if (!ok)
+          qWarning("qt_mac_loadMenuNib: could not instantiate nib");
+  }
++ #endif
+  
+  static void qt_mac_read_fontsmoothing_settings()
+  {
diff -rupN qt-orig/src/gui/kernel/qcocoaapplication_mac.mm qt-patched/src/gui/kernel/qcocoaapplication_mac.mm
--- qt-orig/src/gui/kernel/qcocoaapplication_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qcocoaapplication_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -147,7 +147,7 @@ QT_USE_NAMESPACE
     if ([event type] == NSApplicationDefined) {
         switch ([event subtype]) {
             case QtCocoaEventSubTypePostMessage:
-                [NSApp QT_MANGLE_NAMESPACE(qt_sendPostedMessage):event];
+                [[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_sendPostedMessage):event];
                 return true;
             default:
                 break;
@@ -174,7 +174,7 @@ QT_USE_NAMESPACE
     // be called instead of sendEvent if redirection occurs.
     // 'self' will then be an instance of NSApplication
     // (and not QNSApplication)
-    if (![NSApp QT_MANGLE_NAMESPACE(qt_filterEvent):event])
+    if (![[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_filterEvent):event])
         [self QT_MANGLE_NAMESPACE(qt_sendEvent_original):event];
 }
 
@@ -182,7 +182,7 @@ QT_USE_NAMESPACE
 {
     // This method will be called if
     // no redirection occurs
-    if (![NSApp QT_MANGLE_NAMESPACE(qt_filterEvent):event])
+    if (![[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_filterEvent):event])
         [super sendEvent:event];
 }
 
@@ -194,7 +194,7 @@ QT_USE_NAMESPACE
     // visible on screen. Note: If Qt is used as a plugin, Qt will not use a 
     // native menu bar. Hence, we will also not need to do any redirection etc. as 
     // we do with sendEvent.
-    [[NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
+    [[[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
 }
 
 @end
@@ -203,7 +203,7 @@ QT_BEGIN_NAMESPACE
 
 void qt_redirectNSApplicationSendEvent()
 {
-    if ([NSApp isMemberOfClass:[QT_MANGLE_NAMESPACE(QNSApplication) class]]) {
+    if ([[NSApplication sharedApplication] isMemberOfClass:[QT_MANGLE_NAMESPACE(QNSApplication) class]]) {
         // No need to change implementation since Qt
         // already controls a subclass of NSApplication
         return;
diff -rupN qt-orig/src/gui/kernel/qcocoaapplicationdelegate_mac.mm qt-patched/src/gui/kernel/qcocoaapplicationdelegate_mac.mm
--- qt-orig/src/gui/kernel/qcocoaapplicationdelegate_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qcocoaapplicationdelegate_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -122,7 +122,7 @@ static void cleanupCocoaApplicationDeleg
     [dockMenu release];
     [qtMenuLoader release];
     if (reflectionDelegate) {
-        [NSApp setDelegate:reflectionDelegate];
+        [[NSApplication sharedApplication] setDelegate:reflectionDelegate];
         [reflectionDelegate release];
     }
     [super dealloc];
@@ -183,7 +183,7 @@ static void cleanupCocoaApplicationDeleg
     return [[qtMenuLoader retain] autorelease];
 }
 
-// This function will only be called when NSApp is actually running. Before
+// This function will only be called when NSApplication is actually running. Before
 // that, the kAEQuitApplication Apple event will be sent to
 // QApplicationPrivate::globalAppleEventProcessor in qapplication_mac.mm
 - (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
@@ -249,7 +249,7 @@ static void cleanupCocoaApplicationDeleg
         && [reflectionDelegate respondsToSelector:
                             @selector(applicationShouldTerminateAfterLastWindowClosed:)])
         return [reflectionDelegate applicationShouldTerminateAfterLastWindowClosed:sender];
-    return NO; // Someday qApp->quitOnLastWindowClosed(); when QApp and NSApp work closer together.
+    return NO; // Someday qApp->quitOnLastWindowClosed(); when qApp and NSApplication work closer together.
 }
 
 
@@ -295,7 +295,7 @@ static void cleanupCocoaApplicationDeleg
     QDesktopWidgetImplementation::instance()->onResize();
 }
 
-- (void)setReflectionDelegate:(NSObject <NSApplicationDelegate> *)oldDelegate
+- (void)setReflectionDelegate:(id <NSApplicationDelegate>)oldDelegate
 {
     [oldDelegate retain];
     [reflectionDelegate release];
@@ -342,12 +342,12 @@ static void cleanupCocoaApplicationDeleg
 {
     Q_UNUSED(event);
     Q_UNUSED(replyEvent);
-    [NSApp terminate:self];
+    [[NSApplication sharedApplication] terminate:self];
 }
 
 - (void)qtDispatcherToQAction:(id)sender
 {
-    [[NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
+    [[[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
 }
 
 @end
diff -rupN qt-orig/src/gui/kernel/qcocoaapplicationdelegate_mac.mm.orig qt-patched/src/gui/kernel/qcocoaapplicationdelegate_mac.mm.orig
--- qt-orig/src/gui/kernel/qcocoaapplicationdelegate_mac.mm.orig	1970-01-01 01:00:00.000000000 +0100
+++ qt-patched/src/gui/kernel/qcocoaapplicationdelegate_mac.mm.orig	2014-04-10 19:37:12.000000000 +0100
@@ -0,0 +1,354 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/****************************************************************************
+ **
+ ** Copyright (c) 2007-2008, Apple, Inc.
+ **
+ ** All rights reserved.
+ **
+ ** Redistribution and use in source and binary forms, with or without
+ ** modification, are permitted provided that the following conditions are met:
+ **
+ **   * Redistributions of source code must retain the above copyright notice,
+ **     this list of conditions and the following disclaimer.
+ **
+ **   * Redistributions in binary form must reproduce the above copyright notice,
+ **     this list of conditions and the following disclaimer in the documentation
+ **     and/or other materials provided with the distribution.
+ **
+ **   * Neither the name of Apple, Inc. nor the names of its contributors
+ **     may be used to endorse or promote products derived from this software
+ **     without specific prior written permission.
+ **
+ ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ ** CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ ** EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ ** PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ **
+ ****************************************************************************/
+
+#include "qmacdefines_mac.h"
+#ifdef QT_MAC_USE_COCOA
+
+#import <private/qcocoaapplicationdelegate_mac_p.h>
+#import <private/qcocoamenuloader_mac_p.h>
+#import <private/qcocoaapplication_mac_p.h>
+#include <private/qapplication_p.h>
+#include <private/qt_mac_p.h>
+#include <private/qt_cocoa_helpers_mac_p.h>
+#include <private/qdesktopwidget_mac_p.h>
+#include <qevent.h>
+#include <qurl.h>
+#include <qapplication.h>
+
+QT_BEGIN_NAMESPACE
+extern void onApplicationChangedActivation(bool); // qapplication_mac.mm
+extern void qt_release_apple_event_handler(); //qapplication_mac.mm
+extern QPointer<QWidget> qt_last_mouse_receiver; // qapplication_mac.cpp
+extern QPointer<QWidget> qt_last_native_mouse_receiver; // qt_cocoa_helpers_mac.mm
+extern QPointer<QWidget> qt_button_down; // qapplication_mac.cpp
+
+QT_END_NAMESPACE
+
+QT_FORWARD_DECLARE_CLASS(QDesktopWidgetImplementation)
+QT_USE_NAMESPACE
+
+static QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate) *sharedCocoaApplicationDelegate = nil;
+
+static void cleanupCocoaApplicationDelegate()
+{
+    [sharedCocoaApplicationDelegate release];
+}
+
+@implementation QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate)
+
+- (id)init
+{
+    self = [super init];
+    if (self)
+        inLaunch = true;
+    return self;
+}
+
+- (void)dealloc
+{
+    sharedCocoaApplicationDelegate = nil;
+    [dockMenu release];
+    [qtMenuLoader release];
+    if (reflectionDelegate) {
+        [NSApp setDelegate:reflectionDelegate];
+        [reflectionDelegate release];
+    }
+    [super dealloc];
+}
+
++ (id)allocWithZone:(NSZone *)zone
+{
+    @synchronized(self) {
+        if (sharedCocoaApplicationDelegate == nil) {
+            sharedCocoaApplicationDelegate = [super allocWithZone:zone];
+            return sharedCocoaApplicationDelegate;
+            qAddPostRoutine(cleanupCocoaApplicationDelegate);
+        }
+    }
+    return nil;
+}
+
++ (QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate)*)sharedDelegate
+{
+    @synchronized(self) {
+        if (sharedCocoaApplicationDelegate == nil)
+            [[self alloc] init];
+    }
+    return [[sharedCocoaApplicationDelegate retain] autorelease];
+}
+
+- (void)setDockMenu:(NSMenu*)newMenu
+{
+    [newMenu retain];
+    [dockMenu release];
+    dockMenu = newMenu;
+}
+
+- (NSMenu *)applicationDockMenu
+{
+    return [[dockMenu retain] autorelease];
+}
+
+- (QApplicationPrivate *)qAppPrivate
+{
+    return qtPrivate;
+}
+
+- (void)setQtPrivate:(QApplicationPrivate *)value
+{
+    qtPrivate = value;
+}
+
+- (void)setMenuLoader:(QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *)menuLoader
+{
+    [menuLoader retain];
+    [qtMenuLoader release];
+    qtMenuLoader = menuLoader;
+}
+
+- (QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *)menuLoader
+{
+    return [[qtMenuLoader retain] autorelease];
+}
+
+// This function will only be called when NSApp is actually running. Before
+// that, the kAEQuitApplication Apple event will be sent to
+// QApplicationPrivate::globalAppleEventProcessor in qapplication_mac.mm
+- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
+{
+    Q_UNUSED(sender);
+    // The reflection delegate gets precedence
+    if (reflectionDelegate
+        && [reflectionDelegate respondsToSelector:@selector(applicationShouldTerminate:)]) {
+        return [reflectionDelegate applicationShouldTerminate:sender];
+    }
+
+    if (qtPrivate->canQuit()) {
+        if (!startedQuit) {
+            startedQuit = true;
+            qAppInstance()->quit();
+            startedQuit = false;
+        }
+    }
+
+    if (qtPrivate->threadData->eventLoops.size() == 0) {
+        // INVARIANT: No event loop is executing. This probably
+        // means that Qt is used as a plugin, or as a part of a native
+        // Cocoa application. In any case it should be fine to
+        // terminate now:
+        return NSTerminateNow;
+    }
+
+    return NSTerminateCancel;
+}
+
+- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
+{
+    Q_UNUSED(aNotification);
+    inLaunch = false;
+    qt_release_apple_event_handler();
+}
+
+- (void)application:(NSApplication *)sender openFiles:(NSArray *)filenames
+{
+    for (NSString *fileName in filenames) {
+        QString qtFileName = qt_mac_NSStringToQString(fileName);
+        if (inLaunch) {
+            // We need to be careful because Cocoa will be nice enough to take
+            // command line arguments and send them to us as events. Given the history
+            // of Qt Applications, this will result in behavior people don't want, as
+            // they might be doing the opening themselves with the command line parsing.
+            if (qApp->arguments().contains(qtFileName))
+                continue;
+        }
+        QFileOpenEvent foe(qtFileName);
+        qt_sendSpontaneousEvent(qAppInstance(), &foe);
+    }
+
+    if (reflectionDelegate &&
+        [reflectionDelegate respondsToSelector:@selector(application:openFiles:)])
+        [reflectionDelegate application:sender openFiles:filenames];
+}
+
+- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender
+{
+    // If we have a reflection delegate, that will get to call the shots.
+    if (reflectionDelegate
+        && [reflectionDelegate respondsToSelector:
+                            @selector(applicationShouldTerminateAfterLastWindowClosed:)])
+        return [reflectionDelegate applicationShouldTerminateAfterLastWindowClosed:sender];
+    return NO; // Someday qApp->quitOnLastWindowClosed(); when QApp and NSApp work closer together.
+}
+
+
+- (void)applicationDidBecomeActive:(NSNotification *)notification
+{
+    if (reflectionDelegate
+        && [reflectionDelegate respondsToSelector:@selector(applicationDidBecomeActive:)])
+        [reflectionDelegate applicationDidBecomeActive:notification];
+
+    onApplicationChangedActivation(true);
+
+    if (!QWidget::mouseGrabber()){
+        // Update enter/leave immidiatly, don't wait for a move event. But only
+        // if no grab exists (even if the grab points to this widget, it seems, ref X11)
+        QPoint qlocal, qglobal;
+        QWidget *widgetUnderMouse = 0;
+        qt_mac_getTargetForMouseEvent(0, QEvent::Enter, qlocal, qglobal, 0, &widgetUnderMouse);
+        QApplicationPrivate::dispatchEnterLeave(widgetUnderMouse, 0);
+        qt_last_mouse_receiver = widgetUnderMouse;
+        qt_last_native_mouse_receiver = widgetUnderMouse ?
+            (widgetUnderMouse->internalWinId() ? widgetUnderMouse : widgetUnderMouse->nativeParentWidget()) : 0;
+    }
+}
+
+- (void)applicationDidResignActive:(NSNotification *)notification
+{
+    if (reflectionDelegate
+        && [reflectionDelegate respondsToSelector:@selector(applicationDidResignActive:)])
+        [reflectionDelegate applicationDidResignActive:notification];
+
+    onApplicationChangedActivation(false);
+
+    if (!QWidget::mouseGrabber())
+        QApplicationPrivate::dispatchEnterLeave(0, qt_last_mouse_receiver);
+    qt_last_mouse_receiver = 0;
+    qt_last_native_mouse_receiver = 0;
+    qt_button_down = 0;
+}
+
+- (void)applicationDidChangeScreenParameters:(NSNotification *)notification
+{
+    Q_UNUSED(notification);
+    QDesktopWidgetImplementation::instance()->onResize();
+}
+
+- (void)setReflectionDelegate:(NSObject <NSApplicationDelegate> *)oldDelegate
+{
+    [oldDelegate retain];
+    [reflectionDelegate release];
+    reflectionDelegate = oldDelegate;
+}
+
+- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
+{
+    NSMethodSignature *result = [super methodSignatureForSelector:aSelector];
+    if (!result && reflectionDelegate) {
+        result = [reflectionDelegate methodSignatureForSelector:aSelector];
+    }
+    return result;
+}
+
+- (BOOL)respondsToSelector:(SEL)aSelector
+{
+    BOOL result = [super respondsToSelector:aSelector];
+    if (!result && reflectionDelegate)
+        result = [reflectionDelegate respondsToSelector:aSelector];
+    return result;
+}
+
+- (void)forwardInvocation:(NSInvocation *)invocation
+{
+    SEL invocationSelector = [invocation selector];
+    if (reflectionDelegate && [reflectionDelegate respondsToSelector:invocationSelector])
+        [invocation invokeWithTarget:reflectionDelegate];
+    else
+        [self doesNotRecognizeSelector:invocationSelector];
+}
+
+- (void)getUrl:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor *)replyEvent
+{
+    Q_UNUSED(replyEvent);
+
+    NSString *urlString = [[event paramDescriptorForKeyword:keyDirectObject] stringValue];
+    QUrl url(qt_mac_NSStringToQString(urlString));
+    QFileOpenEvent qtEvent(url);
+    qt_sendSpontaneousEvent(qAppInstance(), &qtEvent);
+}
+
+- (void)appleEventQuit:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor *)replyEvent
+{
+    Q_UNUSED(event);
+    Q_UNUSED(replyEvent);
+    [NSApp terminate:self];
+}
+
+- (void)qtDispatcherToQAction:(id)sender
+{
+    [[NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)] qtDispatcherToQAction:sender];
+}
+
+@end
+#endif
diff -rupN qt-orig/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h qt-patched/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h
--- qt-orig/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qcocoaapplicationdelegate_mac_p.h	2015-03-22 09:25:56.000000000 +0000
@@ -113,7 +113,7 @@ QT_FORWARD_DECLARE_CLASS(QApplicationPri
     QApplicationPrivate *qtPrivate;
     NSMenu *dockMenu;
     QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *qtMenuLoader;
-    NSObject <NSApplicationDelegate> *reflectionDelegate;
+    id <NSApplicationDelegate> reflectionDelegate;
     bool inLaunch;
 }
 + (QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate)*)sharedDelegate;
@@ -122,7 +122,7 @@ QT_FORWARD_DECLARE_CLASS(QApplicationPri
 - (QApplicationPrivate *)qAppPrivate;
 - (void)setMenuLoader:(QT_MANGLE_NAMESPACE(QCocoaMenuLoader)*)menuLoader;
 - (QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *)menuLoader;
-- (void)setReflectionDelegate:(NSObject <NSApplicationDelegate> *)oldDelegate;
+- (void)setReflectionDelegate:(id <NSApplicationDelegate>)oldDelegate;
 - (void)getUrl:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor *)replyEvent;
 @end
 #endif
diff -rupN qt-orig/src/gui/kernel/qcocoamenuloader_mac.mm qt-patched/src/gui/kernel/qcocoamenuloader_mac.mm
--- qt-orig/src/gui/kernel/qcocoamenuloader_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qcocoamenuloader_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -92,8 +92,8 @@ QT_USE_NAMESPACE
     // 'Quit' item. When changing menu bar (e.g when switching between
     // windows with different menu bars), we never recreate this menu, but
     // instead pull it out the current menu bar and place into the new one:
-    NSMenu *mainMenu = [NSApp mainMenu];
-    if ([NSApp mainMenu] == menu)
+    NSMenu *mainMenu = [[NSApplication sharedApplication] mainMenu];
+    if ([[NSApplication sharedApplication] mainMenu] == menu)
         return; // nothing to do (menu is the current menu bar)!
 
 #ifndef QT_NAMESPACE
@@ -201,27 +201,27 @@ QT_USE_NAMESPACE
 
 - (void)terminate:(id)sender
 {
-    [NSApp terminate:sender];
+    [[NSApplication sharedApplication] terminate:sender];
 }
 
 - (void)orderFrontStandardAboutPanel:(id)sender
 {
-    [NSApp orderFrontStandardAboutPanel:sender];
+    [[NSApplication sharedApplication] orderFrontStandardAboutPanel:sender];
 }
 
 - (void)hideOtherApplications:(id)sender
 {
-    [NSApp hideOtherApplications:sender];
+    [[NSApplication sharedApplication] hideOtherApplications:sender];
 }
 
 - (void)unhideAllApplications:(id)sender
 {
-    [NSApp unhideAllApplications:sender];
+    [[NSApplication sharedApplication] unhideAllApplications:sender];
 }
 
 - (void)hide:(id)sender
 {
-    [NSApp hide:sender];
+    [[NSApplication sharedApplication] hide:sender];
 }
 
 - (void)qtUpdateMenubar
@@ -258,7 +258,7 @@ QT_USE_NAMESPACE
 
  - (void)orderFrontCharacterPalette:(id)sender
  {
-     [NSApp orderFrontCharacterPalette:sender];
+     [[NSApplication sharedApplication] orderFrontCharacterPalette:sender];
  }
 
 - (BOOL)validateMenuItem:(NSMenuItem*)menuItem
@@ -266,7 +266,7 @@ QT_USE_NAMESPACE
     if ([menuItem action] == @selector(hide:)
         || [menuItem action] == @selector(hideOtherApplications:)
         || [menuItem action] == @selector(unhideAllApplications:)) {
-        return [NSApp validateMenuItem:menuItem];
+        return [[NSApplication sharedApplication] validateMenuItem:menuItem];
     } else {
         return [menuItem isEnabled];
     }
diff -rupN qt-orig/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h qt-patched/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h
--- qt-orig/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qcocoasharedwindowmethods_mac_p.h	2015-03-22 09:25:56.000000000 +0000
@@ -143,7 +143,7 @@ QT_END_NAMESPACE
 {
     // This function is called from the quit item in the menubar when this window
     // is in the first responder chain (see also qtDispatcherToQAction above)
-    [NSApp terminate:sender];
+    [[NSApplication sharedApplication] terminate:sender];
 }
 
 - (void)setLevel:(NSInteger)windowLevel
@@ -364,7 +364,7 @@ QT_END_NAMESPACE
 
     if ([sender draggingSource] != nil) {
         // modifier flags might have changed, update it here since we don't send any input events.
-        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[NSApp currentEvent] modifierFlags]);
+        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[[NSApplication sharedApplication] currentEvent] modifierFlags]);
         modifiers = QApplication::keyboardModifiers();
     } else {
         // when the source is from another application the above technique will not work.
@@ -456,7 +456,7 @@ QT_END_NAMESPACE
 
     // Update modifiers:
     if ([sender draggingSource] != nil) {
-        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[NSApp currentEvent] modifierFlags]);
+        QApplicationPrivate::modifier_buttons = qt_cocoaModifiers2QtModifiers([[[NSApplication sharedApplication] currentEvent] modifierFlags]);
         modifiers = QApplication::keyboardModifiers();
     } else {
         modifiers = qt_cocoaDragOperation2QtModifiers(nsActions);
diff -rupN qt-orig/src/gui/kernel/qeventdispatcher_mac.mm qt-patched/src/gui/kernel/qeventdispatcher_mac.mm
--- qt-orig/src/gui/kernel/qeventdispatcher_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qeventdispatcher_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -461,7 +461,7 @@ static bool qt_mac_send_event(QEventLoop
     if (pt)
         [pt sendEvent:event];
     else
-        [NSApp sendEvent:event];
+        [[NSApplication sharedApplication] sendEvent:event];
     return true;
 #endif
 }
@@ -521,12 +521,12 @@ static inline void qt_mac_waitForMoreEve
     // (and free up cpu time) until at least one event occur.
     // This implementation is a bit on the edge, but seems to
     // work fine:
-    NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask
+    NSEvent* event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
         untilDate:[NSDate distantFuture]
         inMode:NSDefaultRunLoopMode
         dequeue:YES];
     if (event)
-        [NSApp postEvent:event atStart:YES];
+        [[NSApplication sharedApplication] postEvent:event atStart:YES];
 #endif
 }
 
@@ -537,12 +537,12 @@ static inline void qt_mac_waitForMoreMod
     // (and free up cpu time) until at least one event occur.
     // This implementation is a bit on the edge, but seems to
     // work fine:
-    NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask
+    NSEvent* event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
         untilDate:[NSDate distantFuture]
         inMode:NSModalPanelRunLoopMode
         dequeue:YES];
     if (event)
-        [NSApp postEvent:event atStart:YES];
+        [[NSApplication sharedApplication] postEvent:event atStart:YES];
 }
 #endif
 
@@ -588,23 +588,23 @@ bool QEventDispatcherMac::processEvents(
         // done from the application itself. And if processEvents is called
         // manually (rather than from a QEventLoop), we cannot enter a tight
         // loop and block this call, but instead we need to return after one flush.
-        // Finally, if we are to exclude user input events, we cannot call [NSApp run]
+        // Finally, if we are to exclude user input events, we cannot call [NSApplication run]
         // as we then loose control over which events gets dispatched:
-        const bool canExec_3rdParty = d->nsAppRunCalledByQt || ![NSApp isRunning];
+        const bool canExec_3rdParty = d->nsAppRunCalledByQt || ![[NSApplication sharedApplication] isRunning];
         const bool canExec_Qt = !excludeUserEvents &&
                 (flags & QEventLoop::DialogExec || flags & QEventLoop::EventLoopExec) ;
 
         if (canExec_Qt && canExec_3rdParty) {
             // We can use exec-mode, meaning that we can stay in a tight loop until
             // interrupted. This is mostly an optimization, but it allow us to use
-            // [NSApp run], which is the normal code path for cocoa applications.
+            // [NSApplication run], which is the normal code path for cocoa applications.
             if (NSModalSession session = d->currentModalSession()) {
                 QBoolBlocker execGuard(d->currentExecIsNSAppRun, false);
-                while ([NSApp runModalSession:session] == NSRunContinuesResponse && !d->interrupt)
+                while ([[NSApplication sharedApplication] runModalSession:session] == NSRunContinuesResponse && !d->interrupt)
                     qt_mac_waitForMoreModalSessionEvents();
 
                 if (!d->interrupt && session == d->currentModalSessionCached) {
-                    // Someone called [NSApp stopModal:] from outside the event
+                    // Someone called [[NSApplication sharedApplication] stopModal:] from outside the event
                     // dispatcher (e.g to stop a native dialog). But that call wrongly stopped
                     // 'session' as well. As a result, we need to restart all internal sessions:
                     d->temporarilyStopAllModalSessions();
@@ -612,7 +612,7 @@ bool QEventDispatcherMac::processEvents(
             } else {
                 d->nsAppRunCalledByQt = true;
                 QBoolBlocker execGuard(d->currentExecIsNSAppRun, true);
-                [NSApp run];
+                [[NSApplication sharedApplication] run];
             }
             retVal = true;
         } else {
@@ -626,9 +626,9 @@ bool QEventDispatcherMac::processEvents(
                     // to use cocoa's native way of running modal sessions:
                     if (flags & QEventLoop::WaitForMoreEvents)
                         qt_mac_waitForMoreModalSessionEvents();
-                    NSInteger status = [NSApp runModalSession:session];
+                    NSInteger status = [[NSApplication sharedApplication] runModalSession:session];
                     if (status != NSRunContinuesResponse && session == d->currentModalSessionCached) {
-                        // INVARIANT: Someone called [NSApp stopModal:] from outside the event
+                        // INVARIANT: Someone called [NSApplication stopModal:] from outside the event
                         // dispatcher (e.g to stop a native dialog). But that call wrongly stopped
                         // 'session' as well. As a result, we need to restart all internal sessions:
                         d->temporarilyStopAllModalSessions();
@@ -637,8 +637,8 @@ bool QEventDispatcherMac::processEvents(
                 } else do {
                     // Dispatch all non-user events (but que non-user events up for later). In
                     // this case, we need more control over which events gets dispatched, and
-                    // cannot use [NSApp runModalSession:session]:
-                    event = [NSApp nextEventMatchingMask:NSAnyEventMask
+                    // cannot use [NSApplication runModalSession:session]:
+                    event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
                     untilDate:nil
                     inMode:NSModalPanelRunLoopMode
                     dequeue: YES];
@@ -655,7 +655,7 @@ bool QEventDispatcherMac::processEvents(
                 } while (!d->interrupt && event != nil);
             } else do {
                 // INVARIANT: No modal window is executing.
-                event = [NSApp nextEventMatchingMask:NSAnyEventMask
+                event = [[NSApplication sharedApplication] nextEventMatchingMask:NSAnyEventMask
                 untilDate:nil
                 inMode:NSDefaultRunLoopMode
                 dequeue: YES];
@@ -798,12 +798,12 @@ void QEventDispatcherMacPrivate::ensureN
     // we let Cocoa finish the initialization it seems to need. We'll only
     // apply this trick at most once for any application, and we avoid doing it
     // for the common case where main just starts QApplication::exec.
-    if (nsAppRunCalledByQt || [NSApp isRunning])
+    if (nsAppRunCalledByQt || [[NSApplication sharedApplication] isRunning])
         return;
     nsAppRunCalledByQt = true;
     QBoolBlocker block1(interrupt, true);
     QBoolBlocker block2(currentExecIsNSAppRun, true);
-    [NSApp run];
+    [[NSApplication sharedApplication] run];
 }
 
 void QEventDispatcherMacPrivate::temporarilyStopAllModalSessions()
@@ -812,8 +812,8 @@ void QEventDispatcherMacPrivate::tempora
     // such, make them pending again. The next call to
     // currentModalSession will recreate them again. The
     // reason to stop all session like this is that otherwise
-    // a call [NSApp stop] would not stop NSApp, but rather
-    // the current modal session. So if we need to stop NSApp
+    // a call [NSApplication stop] would not stop NSApplication, but rather
+    // the current modal session. So if we need to stop NSApplication
     // we need to stop all the modal session first. To avoid changing
     // the stacking order of the windows while doing so, we put
     // up a block that is used in QCocoaWindow and QCocoaPanel:
@@ -821,7 +821,7 @@ void QEventDispatcherMacPrivate::tempora
     for (int i=0; i<stackSize; ++i) {
         QCocoaModalSessionInfo &info = cocoaModalSessionStack[i];
         if (info.session) {
-            [NSApp endModalSession:info.session];
+            [[NSApplication sharedApplication] endModalSession:info.session];
             info.session = 0;
         }
     }
@@ -856,7 +856,7 @@ NSModalSession QEventDispatcherMacPrivat
             info.nswindow = window;
             [(NSWindow*) info.nswindow retain];
             int levelBeforeEnterModal = [window level];
-            info.session = [NSApp beginModalSessionForWindow:window];
+            info.session = [[NSApplication sharedApplication] beginModalSessionForWindow:window];
             // Make sure we don't stack the window lower that it was before
             // entering modal, in case it e.g. had the stays-on-top flag set:
             if (levelBeforeEnterModal > [window level])
@@ -926,7 +926,7 @@ void QEventDispatcherMacPrivate::cleanup
         cocoaModalSessionStack.remove(i);
         currentModalSessionCached = 0;
         if (info.session) {
-            [NSApp endModalSession:info.session];
+            [[NSApplication sharedApplication] endModalSession:info.session];
             [(NSWindow *)info.nswindow release];
         }
     }
@@ -1057,7 +1057,7 @@ inline static void processPostedEvents(Q
             // pending cocoa events first).
             if (d->currentModalSessionCached)
                 d->temporarilyStopAllModalSessions();
-            [NSApp stop:NSApp];
+            [[NSApplication sharedApplication] stop:[NSApplication sharedApplication]];
             d->cancelWaitForMoreEvents();
         }
 #endif
@@ -1093,7 +1093,8 @@ void QEventDispatcherMacPrivate::cancelW
     // In case the event dispatcher is waiting for more
     // events somewhere, we post a dummy event to wake it up:
     QMacCocoaAutoReleasePool pool;
-    [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined location:NSZeroPoint
+    [[NSApplication sharedApplication] postEvent:[NSEvent otherEventWithType:NSApplicationDefined
+        location:NSZeroPoint
         modifierFlags:0 timestamp:0. windowNumber:0 context:0
         subtype:QtCocoaEventSubTypeWakeup data1:0 data2:0] atStart:NO];
 }
@@ -1110,7 +1111,7 @@ void QEventDispatcherMac::interrupt()
 #else
     // We do nothing more here than setting d->interrupt = true, and
     // poke the event loop if it is sleeping. Actually stopping
-    // NSApp, or the current modal session, is done inside the send
+    // NSApplication, or the current modal session, is done inside the send
     // posted events callback. We do this to ensure that all current pending
     // cocoa events gets delivered before we stop. Otherwise, if we now stop
     // the last event loop recursion, cocoa will just drop pending posted
@@ -1165,7 +1166,7 @@ QtMacInterruptDispatcherHelp::QtMacInter
     // The whole point of this class is that we enable a way to interrupt
     // the event dispatcher when returning back to a lower recursion level
     // than where interruptLater was called. This is needed to detect if
-    // [NSApp run] should still be running at the recursion level it is at.
+    // [NSApplication run] should still be running at the recursion level it is at.
     // Since the interrupt is canceled if processEvents is called before
     // this object gets deleted, we also avoid interrupting unnecessary.
     deleteLater();
diff -rupN qt-orig/src/gui/kernel/qt_cocoa_helpers_mac.mm qt-patched/src/gui/kernel/qt_cocoa_helpers_mac.mm
--- qt-orig/src/gui/kernel/qt_cocoa_helpers_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qt_cocoa_helpers_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -1697,7 +1697,7 @@ void qt_cocoaPostMessage(id target, SEL 
     NSEvent *e = [NSEvent otherEventWithType:NSApplicationDefined
         location:NSZeroPoint modifierFlags:0 timestamp:0 windowNumber:0
         context:nil subtype:QtCocoaEventSubTypePostMessage data1:lower data2:upper];
-    [NSApp postEvent:e atStart:NO];
+    [[NSApplication sharedApplication] postEvent:e atStart:NO];
 }
 
 void qt_cocoaPostMessageAfterEventLoopExit(id target, SEL selector, int argCount, id arg1, id arg2)
@@ -1727,7 +1727,7 @@ void qt_mac_post_retranslateAppMenu()
 {
 #ifdef QT_MAC_USE_COCOA
     QMacCocoaAutoReleasePool pool;
-    qt_cocoaPostMessage([NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)], @selector(qtTranslateApplicationMenu));
+    qt_cocoaPostMessage([[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)], @selector(qtTranslateApplicationMenu));
 #endif
 }
 
diff -rupN qt-orig/src/gui/kernel/qwidget_mac.mm qt-patched/src/gui/kernel/qwidget_mac.mm
--- qt-orig/src/gui/kernel/qwidget_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/kernel/qwidget_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -220,7 +220,7 @@ static QSize qt_mac_desktopSize()
 static NSDrawer *qt_mac_drawer_for(const QWidget *widget)
 {
     NSView *widgetView = reinterpret_cast<NSView *>(widget->window()->effectiveWinId());
-    NSArray *windows = [NSApp windows];
+    NSArray *windows = [[NSApplication sharedApplication] windows];
     for (NSWindow *window in windows) {
         NSArray *drawers = [window drawers];
         for (NSDrawer *drawer in drawers) {
@@ -254,7 +254,7 @@ static void qt_mac_destructWindow(OSWind
 {
 #ifdef QT_MAC_USE_COCOA
     if ([window isVisible] && [window isSheet]){
-        [NSApp endSheet:window];
+        [[NSApplication sharedApplication] endSheet:window];
         [window orderOut:window];
     }
 
@@ -2439,7 +2439,7 @@ void QWidgetPrivate::recreateMacWindow()
     }
     if ([oldWindow isVisible]){
         if ([oldWindow isSheet])
-            [NSApp endSheet:oldWindow];
+            [[NSApplication sharedApplication] endSheet:oldWindow];
         [oldWindow orderOut:oldWindow];
         show_sys();
     }
@@ -3554,7 +3554,7 @@ void QWidgetPrivate::show_sys()
     }
 
 #ifdef QT_MAC_USE_COCOA
-    if ([NSApp isActive] && !qt_button_down && !QWidget::mouseGrabber()){
+    if ([[NSApplication sharedApplication] isActive] && !qt_button_down && !QWidget::mouseGrabber()){
         // Update enter/leave immidiatly, don't wait for a move event. But only
         // if no grab exists (even if the grab points to this widget, it seems, ref X11)
         QPoint qlocal, qglobal;
@@ -3605,7 +3605,7 @@ void QWidgetPrivate::hide_sys()
             else
                 HideSheetWindow(window);
 #else
-            [NSApp endSheet:window];
+            [[NSApplication sharedApplication] endSheet:window];
             [window orderOut:window];
 #endif
         } else if(qt_mac_is_macdrawer(q)) {
@@ -3716,7 +3716,7 @@ void QWidgetPrivate::hide_sys()
     }
 
 #ifdef QT_MAC_USE_COCOA
-    if ([NSApp isActive] && !qt_button_down && !QWidget::mouseGrabber()){
+    if ([[NSApplication sharedApplication] isActive] && !qt_button_down && !QWidget::mouseGrabber()){
         // Update enter/leave immidiatly, don't wait for a move event. But only
         // if no grab exists (even if the grab points to this widget, it seems, ref X11)
         QPoint qlocal, qglobal;
diff -rupN qt-orig/src/gui/styles/qmacstyle_mac.mm qt-patched/src/gui/styles/qmacstyle_mac.mm
--- qt-orig/src/gui/styles/qmacstyle_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/styles/qmacstyle_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -780,7 +780,7 @@ static QSize qt_aqua_get_known_size(QSty
             if (!GetThemeMenuBarHeight(&size))
                 ret = QSize(-1, size);
 #else
-            ret = QSize(-1, [[NSApp mainMenu] menuBarHeight]);
+            ret = QSize(-1, [[[NSApplication sharedApplication] mainMenu] menuBarHeight]);
             // In the qt_mac_set_native_menubar(false) case,
             // we come it here with a zero-height main menu,
             // preventing the in-window menu from displaying.
diff -rupN qt-orig/src/gui/util/qsystemtrayicon_mac.mm qt-patched/src/gui/util/qsystemtrayicon_mac.mm
--- qt-orig/src/gui/util/qsystemtrayicon_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/util/qsystemtrayicon_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -536,7 +536,7 @@ private:
 #ifndef QT_MAC_USE_COCOA
                 const short scale = GetMBarHeight();
 #else
-                const short scale = [[NSApp mainMenu] menuBarHeight];
+                const short scale = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
 #endif
                 NSImage *nsimage = static_cast<NSImage *>(qt_mac_create_nsimage(icon.pixmap(QSize(scale, scale))));
                 [item setImage: nsimage];
diff -rupN qt-orig/src/gui/widgets/qcocoamenu_mac.mm qt-patched/src/gui/widgets/qcocoamenu_mac.mm
--- qt-orig/src/gui/widgets/qcocoamenu_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/widgets/qcocoamenu_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -202,7 +202,7 @@ QT_USE_NAMESPACE
      static SEL selForOFCP = NSSelectorFromString(@"orderFrontCharacterPalette:");
      if (index == -1 && selForOFCP == actionSelector) {
          // Check if the 'orderFrontCharacterPalette' SEL exists for QCocoaMenuLoader object
-         QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = [NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
+         QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = [[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
          return [super indexOfItemWithTarget:loader andAction:actionSelector];
      }
      return index;
diff -rupN qt-orig/src/gui/widgets/qmenu_mac.mm qt-patched/src/gui/widgets/qmenu_mac.mm
--- qt-orig/src/gui/widgets/qmenu_mac.mm	2014-04-10 19:37:12.000000000 +0100
+++ qt-patched/src/gui/widgets/qmenu_mac.mm	2015-03-22 09:25:56.000000000 +0000
@@ -179,7 +179,7 @@ static void cancelAllMenuTracking()
 {
 #ifdef QT_MAC_USE_COCOA
     QMacCocoaAutoReleasePool pool;
-    NSMenu *mainMenu = [NSApp mainMenu];
+    NSMenu *mainMenu = [[NSApplication sharedApplication] mainMenu];
     [mainMenu cancelTracking];
     for (NSMenuItem *item in [mainMenu itemArray]) {
         if ([item submenu]) {
@@ -633,7 +633,7 @@ static inline void syncMenuBarItemsVisib
 
 static inline QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *getMenuLoader()
 {
-    return [NSApp QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
+    return [[NSApplication sharedApplication] QT_MANGLE_NAMESPACE(qt_qcocoamenuLoader)];
 }
 
 static NSMenuItem *createNSMenuItem(const QString &title)
@@ -2033,7 +2033,7 @@ void qt_mac_clear_menubar()
     QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = getMenuLoader();
     NSMenu *menu = [loader menu];
     [loader ensureAppMenuInMenu:menu];
-    [NSApp setMainMenu:menu];
+    [[NSApplication sharedApplication] setMainMenu:menu];
     const bool modal = qt_mac_should_disable_menu(0);
     if (qt_mac_current_menubar.qmenubar || modal != qt_mac_current_menubar.modal)
         qt_mac_set_modal_state(menu, modal);
@@ -2100,7 +2100,7 @@ bool QMenuBarPrivate::macUpdateMenuBarIm
 #else
             QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = getMenuLoader();
             [loader ensureAppMenuInMenu:menu];
-            [NSApp setMainMenu:menu];
+            [[NSApplication sharedApplication] setMainMenu:menu];
             syncMenuBarItemsVisiblity(mb->d_func()->mac_menubar);
 
             if (OSMenuRef tmpMerge = QMenuPrivate::mergeMenuHash.value(menu)) {
@@ -2140,7 +2140,7 @@ bool QMenuBarPrivate::macUpdateMenuBarIm
 #else
                 QT_MANGLE_NAMESPACE(QCocoaMenuLoader) *loader = getMenuLoader();
                 [loader ensureAppMenuInMenu:menu];
-                [NSApp setMainMenu:menu];
+                [[NSApplication sharedApplication] setMainMenu:menu];
                 syncMenuBarItemsVisiblity(qt_mac_current_menubar.qmenubar->d_func()->mac_menubar);
 #endif
                 qt_mac_set_modal_state(menu, modal);
